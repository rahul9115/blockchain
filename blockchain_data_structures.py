#tuple is not mutable
#dict is mutable stores key value pairs can have duplicate values but not duplicate keys
#list is mutable and can contain duplicate values
# set cannot have duplicate values and is mutable

# What is blockchain it is nothing but a chain blocks each containing a hash generated by all the components of previous block and stores data.
#What is mining ? Adding the outstanding transaction to the blockchain is called Mining
#For a transactions we use dicts, Blockchain since its mutable we use lists, For block we use dicts again and receivers and senders we will use dictionaries for that matter since we dont want to have duplicate values 
from block import Block
blockchain=[]
open_transactions=[]
sender="Max"
block=Block(' ',[],100,0)
blockchain.append(block)
last_block=[]
participants={'Max'}
import hashlib 
import json
import os
import pickle
from pathlib import Path
from transaction import Transaction
mypath=Path("blockchain.p")


def load_data():
    with open("blockchain.json","r") as f:
        file_content=json.loads(f.read())
        global blockchain
        global balance_miner
        blockchain=file_content[0][:-1]
        balance_miner=int(file_content[1])
        
        print(blockchain)
      
if mypath.stat().st_size!=0:
    load_data()        
else:
    balance_miner=0 
print(balance_miner)       
def save_data():
    with open("blockchain.json",mode='w') as f:
        save_data=[block.__dict__ for block in blockchain]
        print("This 1",save_data)
        f.write(json.dumps(str(save_data)))
        f.write("\n")
        f.write(json.dumps(str(balance_miner)))
        
def hashing(last_block):
    return hashlib.sha256(json.dumps(last_block).encode()).hexdigest()
def mine_block(balance_miner):
    print(balance_miner)
   
    mine=Transaction("MINING",sender,balance_miner)
    open_transactions.append(mine)

def balance(participant):
    balance=0
    for i in blockchain:
        for j in i['transactions']:
            
            if 'sender' in j.keys():
                
                if j['sender']==participant:
                    balance=balance_miner
                    print(balance)
                    balance=balance-j['amount']
                
            if 'recipient' in j.keys():
                
                if j['recipient']==participant:
                    balance=balance+j['amount']
                    print(balance)
                               

    

    return balance        


def add_transactions(sender,recipient,amount):
    transaction=Transaction(sender,recipient,amount)
    participants.add(sender)
    participants.add(recipient)
    open_transactions.append(transaction)
   
    
def enter_transaction():
    recipient=input("Enter the recipient: ")
    
    amount=float(input("Enter the transaction amount: "))
    
    return recipient,amount
def valid_proof(transactions,last_hash,proof):
    print(transactions,last_hash,proof)
    guess=(str(transactions)+str(last_hash)+str(proof)).encode()
    guess_hash=hashlib.sha256(guess).hexdigest()
    return guess_hash[0:2]=="00"

def proof_of_work():
    last_block=blockchain[-1].__dict__
    print("This is last block: ",last_block)
    last_hash=hashing(last_block)
    print("This is previous last hash: "+last_hash)
    proof=0
    while (valid_proof(open_transactions,last_hash,proof)==False):
        proof +=1
    return proof    

while True:
    
    print("\n 1.To add Transaction \n 2.Mine a Block \n 3.Verify the blockchain \n 4.Display the blockchain \n 5.Participants \n 6.Balance \n 7.Display senders and recipients \n 8.Quit")
    a=int(input("Enter the value: "))
   
    if a==1:
        
        while True:
            data=enter_transaction()
            recipient,amount=data
            print(balance_miner,amount)
            if (balance_miner<amount):
                print("You dont have enough")
                break
            add_transactions(sender,recipient,amount)
            print(open_transactions)
            while True:
                y=input("Do you want to continue y/n")
                if y=='y' or y=='n':
                    break
                else: 
                    print("Enter valid input")
                    continue
            if y=='y':
                continue
            elif y=='n':
                break


    if a==2:
        
        balance_miner=balance_miner+10
        mine_block(balance_miner)
        last_block=blockchain[-1].__dict__
        hashed=hashing(last_block)
        proof=proof_of_work()
        print(proof)
        block=Block(hashed,open_transactions,proof)
        print("This: ",block.__dict__)
        blockchain.append(block)
        save_data()
        open_transactions=[]
        

    if a==3:
        k=True
        print(len(blockchain))
        for i in range(len(blockchain)-1,0,-1):
            
           
            if hashing(blockchain[i-1])!=blockchain[i]['previous_hash'] or valid_proof(blockchain[i]['transactions'],blockchain[i]['previous_hash'],blockchain[i]['proof'])==False:
               
                k=False
                break
               
        if k==True:
            print("Perfect Blockchain")
        else:
            print("Error in blockchain")                       


    if a==4:
      print(blockchain)
    if a==5:
        print(participants)
    if a==6:
       participant=input("Enter the participant")
       balance1=balance(participant)
       print(balance1)
    if a==7:
        pass
    if a==8:
        break               
    else: 
        print("Please enter valid value")
        continue    
